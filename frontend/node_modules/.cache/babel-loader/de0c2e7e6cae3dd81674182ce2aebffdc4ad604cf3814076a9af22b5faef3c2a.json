{"ast":null,"code":"import forge from 'node-forge';\nclass ClientCrypto {\n  // Generate challenge signature for login - FIXED: Now returns hex format to match backend\n  static signChallenge(challenge, privateKeyPem) {\n    try {\n      const privateKey = forge.pki.privateKeyFromPem(privateKeyPem);\n      const md = forge.md.sha256.create();\n      md.update(challenge, 'utf8');\n      const signature = privateKey.sign(md);\n      return forge.util.bytesToHex(signature); // Changed from encode64 to bytesToHex\n    } catch (error) {\n      throw new Error('Failed to sign challenge: ' + error.message);\n    }\n  }\n\n  // Verify digital signature\n  static verifySignature(data, signature, publicKeyPem) {\n    try {\n      const publicKey = forge.pki.publicKeyFromPem(publicKeyPem);\n      const md = forge.md.sha256.create();\n      md.update(data, 'utf8');\n      const signatureBytes = forge.util.hexToBytes(signature); // Updated to handle hex format\n      return publicKey.verify(md.digest().bytes(), signatureBytes);\n    } catch (error) {\n      return false;\n    }\n  }\n\n  // Create digital signature - FIXED: Now returns hex format to match backend\n  static createSignature(data, privateKeyPem) {\n    try {\n      const privateKey = forge.pki.privateKeyFromPem(privateKeyPem);\n      const md = forge.md.sha256.create();\n      md.update(data, 'utf8');\n      const signature = privateKey.sign(md);\n      return forge.util.bytesToHex(signature); // Changed from encode64 to bytesToHex\n    } catch (error) {\n      throw new Error('Failed to create signature: ' + error.message);\n    }\n  }\n\n  // Encrypt data with public key (for small data like AES keys)\n  static encryptWithPublicKey(data, publicKeyPem) {\n    try {\n      const publicKey = forge.pki.publicKeyFromPem(publicKeyPem);\n      const encrypted = publicKey.encrypt(data, 'RSA-OAEP');\n      return forge.util.encode64(encrypted);\n    } catch (error) {\n      throw new Error('Failed to encrypt with public key: ' + error.message);\n    }\n  }\n\n  // Decrypt data with private key\n  static decryptWithPrivateKey(encryptedData, privateKeyPem) {\n    try {\n      const privateKey = forge.pki.privateKeyFromPem(privateKeyPem);\n      const encrypted = forge.util.decode64(encryptedData);\n      const decrypted = privateKey.decrypt(encrypted, 'RSA-OAEP');\n      return decrypted;\n    } catch (error) {\n      throw new Error('Failed to decrypt with private key: ' + error.message);\n    }\n  }\n\n  // Generate random AES key\n  static generateAESKey() {\n    return forge.random.getBytesSync(32); // 256-bit key\n  }\n\n  // Encrypt data with AES\n  static encryptAES(data, key) {\n    try {\n      const cipher = forge.cipher.createCipher('AES-CBC', key);\n      const iv = forge.random.getBytesSync(16);\n      cipher.start({\n        iv: iv\n      });\n      cipher.update(forge.util.createBuffer(data, 'utf8'));\n      cipher.finish();\n      return {\n        encrypted: forge.util.encode64(cipher.output.data),\n        iv: forge.util.encode64(iv)\n      };\n    } catch (error) {\n      throw new Error('Failed to encrypt with AES: ' + error.message);\n    }\n  }\n\n  // Decrypt data with AES\n  static decryptAES(encryptedData, key, iv) {\n    try {\n      const decipher = forge.cipher.createDecipher('AES-CBC', key);\n      const encryptedBytes = forge.util.decode64(encryptedData);\n      const ivBytes = forge.util.decode64(iv);\n      decipher.start({\n        iv: ivBytes\n      });\n      decipher.update(forge.util.createBuffer(encryptedBytes));\n      decipher.finish();\n      return decipher.output.toString('utf8');\n    } catch (error) {\n      throw new Error('Failed to decrypt with AES: ' + error.message);\n    }\n  }\n\n  // Generate hash\n  static generateHash(data) {\n    const md = forge.md.sha256.create();\n    md.update(data, 'utf8');\n    return md.digest().toHex();\n  }\n\n  // Validate PEM format\n  static isValidPEM(pem, type = 'PRIVATE KEY') {\n    try {\n      const regex = new RegExp(`-----BEGIN ${type}-----[\\\\s\\\\S]*-----END ${type}-----`);\n      return regex.test(pem);\n    } catch (error) {\n      return false;\n    }\n  }\n\n  // Extract public key from certificate\n  static getPublicKeyFromCert(certPem) {\n    try {\n      const cert = forge.pki.certificateFromPem(certPem);\n      return forge.pki.publicKeyToPem(cert.publicKey);\n    } catch (error) {\n      throw new Error('Failed to extract public key from certificate');\n    }\n  }\n\n  // Verify certificate validity\n  static verifyCertificate(certPem) {\n    try {\n      const cert = forge.pki.certificateFromPem(certPem);\n      const now = new Date();\n      return now >= cert.validity.notBefore && now <= cert.validity.notAfter;\n    } catch (error) {\n      return false;\n    }\n  }\n}\nexport default ClientCrypto;","map":{"version":3,"names":["forge","ClientCrypto","signChallenge","challenge","privateKeyPem","privateKey","pki","privateKeyFromPem","md","sha256","create","update","signature","sign","util","bytesToHex","error","Error","message","verifySignature","data","publicKeyPem","publicKey","publicKeyFromPem","signatureBytes","hexToBytes","verify","digest","bytes","createSignature","encryptWithPublicKey","encrypted","encrypt","encode64","decryptWithPrivateKey","encryptedData","decode64","decrypted","decrypt","generateAESKey","random","getBytesSync","encryptAES","key","cipher","createCipher","iv","start","createBuffer","finish","output","decryptAES","decipher","createDecipher","encryptedBytes","ivBytes","toString","generateHash","toHex","isValidPEM","pem","type","regex","RegExp","test","getPublicKeyFromCert","certPem","cert","certificateFromPem","publicKeyToPem","verifyCertificate","now","Date","validity","notBefore","notAfter"],"sources":["/workspace/frontend/src/utils/crypto.js"],"sourcesContent":["import forge from 'node-forge';\n\nclass ClientCrypto {\n  // Generate challenge signature for login - FIXED: Now returns hex format to match backend\n  static signChallenge(challenge, privateKeyPem) {\n    try {\n      const privateKey = forge.pki.privateKeyFromPem(privateKeyPem);\n      const md = forge.md.sha256.create();\n      md.update(challenge, 'utf8');\n      const signature = privateKey.sign(md);\n      return forge.util.bytesToHex(signature); // Changed from encode64 to bytesToHex\n    } catch (error) {\n      throw new Error('Failed to sign challenge: ' + error.message);\n    }\n  }\n\n  // Verify digital signature\n  static verifySignature(data, signature, publicKeyPem) {\n    try {\n      const publicKey = forge.pki.publicKeyFromPem(publicKeyPem);\n      const md = forge.md.sha256.create();\n      md.update(data, 'utf8');\n      const signatureBytes = forge.util.hexToBytes(signature); // Updated to handle hex format\n      return publicKey.verify(md.digest().bytes(), signatureBytes);\n    } catch (error) {\n      return false;\n    }\n  }\n\n  // Create digital signature - FIXED: Now returns hex format to match backend\n  static createSignature(data, privateKeyPem) {\n    try {\n      const privateKey = forge.pki.privateKeyFromPem(privateKeyPem);\n      const md = forge.md.sha256.create();\n      md.update(data, 'utf8');\n      const signature = privateKey.sign(md);\n      return forge.util.bytesToHex(signature); // Changed from encode64 to bytesToHex\n    } catch (error) {\n      throw new Error('Failed to create signature: ' + error.message);\n    }\n  }\n\n  // Encrypt data with public key (for small data like AES keys)\n  static encryptWithPublicKey(data, publicKeyPem) {\n    try {\n      const publicKey = forge.pki.publicKeyFromPem(publicKeyPem);\n      const encrypted = publicKey.encrypt(data, 'RSA-OAEP');\n      return forge.util.encode64(encrypted);\n    } catch (error) {\n      throw new Error('Failed to encrypt with public key: ' + error.message);\n    }\n  }\n\n  // Decrypt data with private key\n  static decryptWithPrivateKey(encryptedData, privateKeyPem) {\n    try {\n      const privateKey = forge.pki.privateKeyFromPem(privateKeyPem);\n      const encrypted = forge.util.decode64(encryptedData);\n      const decrypted = privateKey.decrypt(encrypted, 'RSA-OAEP');\n      return decrypted;\n    } catch (error) {\n      throw new Error('Failed to decrypt with private key: ' + error.message);\n    }\n  }\n\n  // Generate random AES key\n  static generateAESKey() {\n    return forge.random.getBytesSync(32); // 256-bit key\n  }\n\n  // Encrypt data with AES\n  static encryptAES(data, key) {\n    try {\n      const cipher = forge.cipher.createCipher('AES-CBC', key);\n      const iv = forge.random.getBytesSync(16);\n      cipher.start({ iv: iv });\n      cipher.update(forge.util.createBuffer(data, 'utf8'));\n      cipher.finish();\n      \n      return {\n        encrypted: forge.util.encode64(cipher.output.data),\n        iv: forge.util.encode64(iv)\n      };\n    } catch (error) {\n      throw new Error('Failed to encrypt with AES: ' + error.message);\n    }\n  }\n\n  // Decrypt data with AES\n  static decryptAES(encryptedData, key, iv) {\n    try {\n      const decipher = forge.cipher.createDecipher('AES-CBC', key);\n      const encryptedBytes = forge.util.decode64(encryptedData);\n      const ivBytes = forge.util.decode64(iv);\n      \n      decipher.start({ iv: ivBytes });\n      decipher.update(forge.util.createBuffer(encryptedBytes));\n      decipher.finish();\n      \n      return decipher.output.toString('utf8');\n    } catch (error) {\n      throw new Error('Failed to decrypt with AES: ' + error.message);\n    }\n  }\n\n  // Generate hash\n  static generateHash(data) {\n    const md = forge.md.sha256.create();\n    md.update(data, 'utf8');\n    return md.digest().toHex();\n  }\n\n  // Validate PEM format\n  static isValidPEM(pem, type = 'PRIVATE KEY') {\n    try {\n      const regex = new RegExp(`-----BEGIN ${type}-----[\\\\s\\\\S]*-----END ${type}-----`);\n      return regex.test(pem);\n    } catch (error) {\n      return false;\n    }\n  }\n\n  // Extract public key from certificate\n  static getPublicKeyFromCert(certPem) {\n    try {\n      const cert = forge.pki.certificateFromPem(certPem);\n      return forge.pki.publicKeyToPem(cert.publicKey);\n    } catch (error) {\n      throw new Error('Failed to extract public key from certificate');\n    }\n  }\n\n  // Verify certificate validity\n  static verifyCertificate(certPem) {\n    try {\n      const cert = forge.pki.certificateFromPem(certPem);\n      const now = new Date();\n      return now >= cert.validity.notBefore && now <= cert.validity.notAfter;\n    } catch (error) {\n      return false;\n    }\n  }\n}\n\nexport default ClientCrypto;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}